/*
 *   Copyright (c) 2025 Riverside Research.
 *   LGPL-3; See LICENSE.txt in the repo root for details.
 */

#pragma once

#include "CVEAssert.hpp"

#include "llvm/Support/JSON.h"
#include "llvm/Support/raw_ostream.h"

#include <cstdint>
#include <fstream>
#include <optional>
#include <string>
#include <vector>
#include <sstream>

struct Vulnerability {

  enum RemediationStrategies {
    NONE = 0,       /* Skip remediation for this vulnerability */
    RECOVER = 1,    /* Applies setjmp and longjmp in vulnerable function */
    SAT = 2,        /* Applies saturated arithmetic in vulnerable function */
    EXIT = 3,       /* Inserts exit function call with exit code */
    CONTINUE = 4,   /* Inserts a value that allows program to continue forward execution
                       the resulting state of the program may be undefined */
    /* Widen potentially overflowing intermediate operations */
    CONTINUE_WIDEN = 5
  };

  std::string TargetFileName;
  std::string TargetFunctionName;
  std::string WeaknessName;
  uint32_t WeaknessID;
  std::optional<std::string> UndesirableFunction;
  RemediationStrategies Strategy;
  // std::optional<std::string> Condition;

  static std::optional<Vulnerability> fromJson(llvm::json::Object *jsonObj) {
    // Retrieve the target file name.
    auto targetFile = jsonObj->getString("affected-file");
    if (!targetFile) {
      llvm::errs()
          << "[CVEAssert] Error: JSON does not contain 'affected-file' key.\n";
      return std::nullopt;
    }

    // Retrieve the target function name.
    auto targetFunction = jsonObj->getString("affected-function");
    if (!targetFunction) {
      llvm::errs() << "[CVEAssert] Error: JSON does not contain "
                      "'affected-function' key.\n";
      return std::nullopt;
    }

    // Retrieve weakness types.
    auto vulnName = jsonObj->getString("cwe-name");
    if (!vulnName) {
      llvm::errs() << "[CVEAssert] Error: No 'cwe-name' field found in JSON.\n";
      return std::nullopt;
    }
    auto vulnType = jsonObj->getString("cwe-id");
    if (!vulnType) {
      llvm::errs() << "[CVEAssert] Error: No 'cwe-id' field found in JSON.\n";
      return std::nullopt;
    }

    /*
    auto condition = jsonObj->getString("undesirable-condition");
    if (!condition) {
      llvm::errs() << "[CVEAssert] Error: No 'undesirable-condition' field found
    in JSON.\n"; return std::nullopt;
    }
    */

    std::optional<std::string> undesirableFunction = std::nullopt;
    if (auto uf = jsonObj->getString("undesirable-function")) {
      undesirableFunction = uf->str();
    }

    auto remediation = jsonObj->getString("remediation-strategy");
    RemediationStrategies strategy;

    if (!remediation) {
      llvm::errs() << "[CVEAssert] Warning: remediation-strategy is not specified "
                   << "defaulting to CONTINUE strategy!\n";
      strategy = RemediationStrategies::CONTINUE;

    } else if (remediation->str() == "widen" ||
               remediation->str() == "continue-widen") {
      strategy = RemediationStrategies::CONTINUE_WIDEN;
    } else if (remediation->str() == "sat") {
      strategy = RemediationStrategies::SAT;
    } else if (remediation->str() == "exit") {
      strategy = RemediationStrategies::EXIT;
    } else if (remediation->str() == "continue") {
      strategy = RemediationStrategies::CONTINUE;
    } else if (remediation->str() == "recover") {
      strategy = RemediationStrategies::RECOVER;
    } else if (remediation->str() == "none") {
      strategy = RemediationStrategies::NONE;
    } else {
      llvm::errs() << "[CVEAssert] Warning: remediation-strategy is not recognized "
                   << "defaulting to CONTINUE strategy!\n"; 
      strategy = RemediationStrategies::CONTINUE;
    }

    Vulnerability vuln{
        targetFile->str(),
        targetFunction->str(),
        vulnName->str(),
        static_cast<uint32_t>(std::stoi(vulnType->str())),
        undesirableFunction,
        strategy,
        // std::make_optional(condition->str())
    };
    return std::make_optional(vuln);
  }

  static std::vector<Vulnerability> parseVulnerabilityFile() {
    std::vector<Vulnerability> vulnerabilities;

    // Read the JSON configuration file path from the environment variable.
    const char *envPath = std::getenv("RESOLVE_LABEL_CVE");
    if (!envPath) {
      // This is noisy if you don't care about remediation
      if (CVE_ASSERT_DEBUG) {
        llvm::errs() << "[CVEAssert] Error: RESOLVE_LABEL_CVE environment "
                        "variable not set!\n";
      }
      return {};
    }
    std::ifstream file(envPath);
    if (!file) {
      llvm::errs() << "[CVEAssert] Error: Unable to open file: " << envPath
                   << "\n";
      return {};
    }
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();

    // Parse the JSON configuration.
    auto jsonOrError = llvm::json::parse(content);
    if (!jsonOrError) {
      llvm::errs() << "[CVEAssert] Error parsing JSON from file: " << envPath
                   << "\n";
      return {};
    }
    llvm::json::Value jsonVal = std::move(*jsonOrError);
    auto *jsonObj = jsonVal.getAsObject();
    if (!jsonObj) {
      llvm::errs() << "[CVEAssert] Error: JSON is not an object.\n";
    }

    // Retrive the vulnerabilites
    auto *vulns = jsonObj->getArray("vulnerabilities");
    if (!vulns) {
      llvm::errs() << "[CVEAssert] Error: JSON does not contain "
                      "'vulnerabilities' array.\n";
    }

    if (vulns->empty()) {
      llvm::errs() << "[CVEAssert] Error: 'vulnerabilities' array is empty.\n";
    }

    for (llvm::json::Value vuln_json : *vulns) {
      auto vuln_obj = vuln_json.getAsObject();
      if (!vuln_obj) {
        llvm::errs()
            << "[CVEAssert] Error: 'vulnerabilities' item is not object.\n";
      }
      auto vuln = Vulnerability::fromJson(vuln_obj);
      if (vuln) {
        vulnerabilities.push_back(*vuln);
      }
    }
    return vulnerabilities;
  }
};
