
#pragma once

#include "CVEAssert.hpp"

#include "llvm/Support/JSON.h"
#include "llvm/Support/raw_ostream.h"

#include <cstdint>
#include <fstream>
#include <optional>
#include <string>
#include <vector>

struct Vulnerability {
  std::string TargetFileName;
  std::string TargetFunctionName;
  std::string WeaknessName;
  uint32_t WeaknessID;
  std::optional<std::string> UndesirableFunction;
  // std::optional<std::string> Condition;

  static std::optional<Vulnerability> fromJson(llvm::json::Object *jsonObj) {
    // Retrieve the target file name.
    auto targetFile = jsonObj->getString("affected-file");
    if (!targetFile) {
      llvm::errs()
          << "[CVEAssert] Error: JSON does not contain 'affected-file' key.\n";
      return std::nullopt;
    }

    // Retrieve the target function name.
    auto targetFunction = jsonObj->getString("affected-function");
    if (!targetFunction) {
      llvm::errs() << "[CVEAssert] Error: JSON does not contain "
                      "'affected-function' key.\n";
      return std::nullopt;
    }

    // Retrieve weakness types.
    auto vulnName = jsonObj->getString("cwe-name");
    if (!vulnName) {
      llvm::errs() << "[CVEAssert] Error: No 'cwe-name' field found in JSON.\n";
      return std::nullopt;
    }
    auto vulnType = jsonObj->getString("cwe-id");
    if (!vulnType) {
      llvm::errs() << "[CVEAssert] Error: No 'cwe-id' field found in JSON.\n";
      return std::nullopt;
    }

    /*
    auto condition = jsonObj->getString("undesirable-condition");
    if (!condition) {
      llvm::errs() << "[CVEAssert] Error: No 'undesirable-condition' field found
    in JSON.\n"; return std::nullopt;
    }
    */

    std::optional<std::string> undesirableFunction = std::nullopt;
    if (auto uf = jsonObj->getString("undesirable-function")) {
      undesirableFunction = uf->str();
    }

    Vulnerability vuln{
        targetFile->str(),
        targetFunction->str(),
        vulnName->str(),
        static_cast<uint32_t>(std::stoi(vulnType->str())),
        undesirableFunction,
        // std::make_optional(condition->str())
    };
    return std::make_optional(vuln);
  }

  static std::vector<Vulnerability> parseVulnerabilityFile() {
    std::vector<Vulnerability> vulnerabilities;

    // Read the JSON configuration file path from the environment variable.
    const char *envPath = std::getenv("RESOLVE_LABEL_CVE");
    if (!envPath) {
      // This is noisy if you don't care about remediation
      if (CVE_ASSERT_DEBUG) {
        llvm::errs() << "[CVEAssert] Error: RESOLVE_LABEL_CVE environment "
                        "variable not set!\n";
      }
      return {};
    }
    std::ifstream file(envPath);
    if (!file) {
      llvm::errs() << "[CVEAssert] Error: Unable to open file: " << envPath
                   << "\n";
      return {};
    }
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();

    // Parse the JSON configuration.
    auto jsonOrError = llvm::json::parse(content);
    if (!jsonOrError) {
      llvm::errs() << "[CVEAssert] Error parsing JSON from file: " << envPath
                   << "\n";
      return {};
    }
    llvm::json::Value jsonVal = std::move(*jsonOrError);
    auto *jsonObj = jsonVal.getAsObject();
    if (!jsonObj) {
      llvm::errs() << "[CVEAssert] Error: JSON is not an object.\n";
    }

    // Retrive the vulnerabilites
    auto *vulns = jsonObj->getArray("vulnerabilities");
    if (!vulns) {
      llvm::errs() << "[CVEAssert] Error: JSON does not contain "
                      "'vulnerabilities' array.\n";
    }

    if (vulns->empty()) {
      llvm::errs() << "[CVEAssert] Error: 'vulnerabilities' array is empty.\n";
    }

    for (llvm::json::Value vuln_json : *vulns) {
      auto vuln_obj = vuln_json.getAsObject();
      if (!vuln_obj) {
        llvm::errs()
            << "[CVEAssert] Error: 'vulnerabilities' item is not object.\n";
      }
      auto vuln = Vulnerability::fromJson(vuln_obj);
      if (vuln) {
        vulnerabilities.push_back(*vuln);
      }
    }
    return vulnerabilities;
  }
};
